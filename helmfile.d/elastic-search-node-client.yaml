repositories:
  {{ $s3Bucket     := env "HELM_S3_BUCKET"      | default "openraven-deploy" }}
  {{ $s3BucketHost := env "HELM_S3_BUCKET_HOST" | default "s3.amazonaws.com" }}
  {{ $ourUrl       := env "HELM_S3_URL"         | default (printf "https://%s.%s/charts" $s3Bucket $s3BucketHost) }}
  {{ $ingHostname  := requiredEnv "OPENRAVEN_INGRESS_HOSTNAME" }}
  - name: openraven
    url: {{ $ourUrl }}

releases:
- name: elastic-search-node-client
  namespace: ui
  chart: openraven/elastic-search-node-client
  version: 0.171888549.1
  missingFileHandler: Warn
  installed: true
  hooks:
    # This is a terrible option but is really the only viable solution outside of having cluster upgrade do
    # the dirty work.
    # https://github.com/roboll/helmfile/issues/471
  - events: ["prepare"]
    showlogs: true
    command: bash
    args:
    - -exc
    - |
      my_ns="{{`{{ .Release.Namespace }}`}}"
      my_name="{{`{{ .Release.Name }}`}}"
      if ! helm status -n $my_ns $my_name | grep -q deployed; then
           echo "Remove $my_name because it is not deployed"
           # swallow the error intentionally to install no matter what.
           helm uninstall -n $my_ns $my_name || true
      fi
  - events: ["presync"]
    showlogs: true
    command: bash
    args:
    - -exc
    - |
      my_ns="{{`{{ .Release.Namespace }}`}}"
      if ! kubectl get -o name namespace $my_ns; then
           kubectl create      namespace $my_ns
      fi
  values:
  - global:
      frontEndClientId: {{ requiredEnv "FRONTEND_CLIENT_ID" }}
      groupId: {{ requiredEnv "GROUP_ID" }}
      serviceClientId: {{ requiredEnv "SERVICE_CLIENT_ID" }}
      serviceClientSecret: {{ requiredEnv "SERVICE_CLIENT_SECRET" }}
      openravenIngressHostname: {{ $ingHostname }}
  - elasticsearch_load:
      bucketname: {{ $s3Bucket }}
  - ingress:
      tls:
      # be careful, this needs to be the same name from productui.yaml
      - secretName: www-tls
        hosts:
        - {{ $ingHostname }}
